// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "IVM_ADERDG.h"

#include "IVM_ADERDG_Variables.h"

#include "kernels/KernelUtils.h"

#include "kernels/GaussLegendreBasis.h"
#include "kernels/aderdg/generic/Kernels.h"
#include "cmath"

#include "peano/utils/Loop.h"

tarch::logging::Log IVM::IVM_ADERDG::_log( "IVM::IVM_ADERDG" );

bool create_file = true;
bool write_file = true;
bool read_file = true;

struct ParaReadIn { // This structure is named "myDataType"
  double lambda;
  double mu;
  double xi;
  double rho;
  double gamma;
  double tau1;
  double Cd;
  double Cr;
  double e0;
  double beta;
  double delta;

  double exx0 = -1e-5;
  double eyy0 = -1e-5;
  double exy0 = 2.56e5;  
};

ParaReadIn paraInput;

std::vector<double> var_in(5);

double setYourExactData(const double* const x, const double t){
  double PI = 3.141592654;
  double fc = 74e3;
  double fc_pro = 600e3;
  // double tc1 = 3/fc;
  // double A_amp = 1e-6*(t/tc1)*(3-9*t/4/tc1);
  // double A_amp = 5e-5*( 1-1.5*std::abs((t/tc1)-0.6667) );
  double tc1 = 4/fc;
  double tc2 = 0.5/fc_pro;
  
  double A_amp = 2.5e-6*( 1.0-2.0*std::abs((t/tc1)-0.5) );
  // double A_amp = 2.5e-6*( 1.0 );

  // double A_amp = 5e-5*4*( (1.0-t/tc1)*t/tc1 );

  double s_sou;

  if (t<tc1 && std::sqrt(x[0]*x[0]) < 0.01 && std::sqrt((x[1]-0.11)*(x[1]-0.11)) < 0.02){
    s_sou = A_amp*std::sin(2*PI*fc*t);
  }
  else if (t<tc2 && std::sqrt(x[0]*x[0]) < 0.00101 && std::sqrt((x[1]-0.065)*(x[1]-0.065)) < 0.005){
    s_sou = 0e-6*std::sin(2*PI*fc_pro*t);
  }
  else{
    s_sou = 0;
  }

  return s_sou;
}


void IVM::IVM_ADERDG::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  
  // @todo Please implement/augment if required

    
}

void IVM::IVM_ADERDG::adjustPointSolution(const double* const x,const double t,const double dt,double* const Q) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  
  // @todo Please implement/augment if required
  // std::cout<<paraInput.exx0<<std::endl;
  if (tarch::la::equals(t,0.0)) {
    // std::cout << "Entered Output======" << std::endl;
    std::string home_dir = std::getenv("SHARED_DIR");
    // std::string finame;
    // finame = home_dir + "/Exahype/out.txt";
    // std::ofstream outputsfile;
    // if (create_file) {
    //   outputsfile.open(finame, std::ios_base::trunc);
    //   outputsfile.close();
    //   create_file = false;
    // }
    // if (write_file){
    //   std::cout << finame << std::endl;
    //   outputsfile.open(finame, std::ios_base::app);
    //   outputsfile << std::fixed << std::setprecision(3);
    //   for(int i = 0; i<7; i++) outputsfile << Q[i] << "\n";
    //   outputsfile.close();
    //   write_file = false;
    // }
    std::string finame_in;
    finame_in = home_dir + "/in.txt";
    std::ifstream inputsfile;
    
    if (read_file){
      read_file = false;
      std::cout << "Reading from " << finame_in << "\n";
      inputsfile.open(finame_in, std::ios_base::in);
      inputsfile >> std::fixed >> std::scientific;
      for(int i=0; i<4; i++){
        inputsfile >> var_in[i];
        std::cout << "Read in: " << var_in[i] << "\n";
      }
      paraInput.lambda = 4.72e9;
      paraInput.mu = 7.08e9;
      paraInput.xi = 0.79;//var_in[0]
      paraInput.rho = 2.3e3;
      paraInput.e0 = 0.5e-7*std::pow(10,var_in[0]);
      paraInput.gamma = 4.5e9*var_in[1];
      paraInput.tau1 = 1e-5;
      paraInput.Cr = 4e7*std::pow(10,var_in[3]);
      paraInput.Cd = 2e5*std::pow(var_in[2],1);
      // paraInput.beta = 180*var_in[0];
      // paraInput.delta = 3e8*var_in[1];

      // mu0 = var_in;
      // rho0 = var_in;
      paraInput.exx0 = -paraInput.e0;
      paraInput.eyy0 = -paraInput.e0;
      paraInput.exy0 = 1.46*paraInput.e0;  

      std::cout << "Read-in parameters\n";
      std::cout << "lambda0 = " << paraInput.lambda  << std::endl;
      std::cout << "mu0     = " << paraInput.mu << std::endl;
      std::cout << "xi0    = " << paraInput.xi  << std::endl;
      std::cout << "rho0    = " << paraInput.rho << std::endl;
      std::cout << "gamma0  = " << paraInput.gamma << std::endl;
      std::cout << "Cd   = " << paraInput.Cd << std::endl;
       
    }
    Q[0] = paraInput.exx0;
    Q[1] = paraInput.eyy0;
    Q[2] = paraInput.exy0;
    Q[3] = 0.0;
    Q[4] = 0.0;
    Q[5] = 0.0;
    // Q[6] = var_in;
    // if (Q[6]>0.1) {
    //   std::cout << "Lambda111: " << var_in << ", Q[6]: " << Q[6] << "\n";
    // }
    
    
  }
  // Q[5] = 1e-3;
  Q[6] = -Q[5];

  double lambda_m = paraInput.lambda; //12.5e9;
  double mu_m = paraInput.mu; //18.75e9;
  double rho_m = paraInput.rho;
  double gamma_m = paraInput.gamma;
//  double l_m = -0.0e5;
//  double m_m = -0.0e5;
  VariableShortcuts s;

  double vx = Q[s.v]; double vy = Q[s.v+1];
  double exx = Q[s.e]; double eyy = Q[s.e+1]; double exy = Q[s.e+2];
  double g_int = Q[s.gint];

  double EI = exx + eyy;
  double EII = (exx*exx + eyy*eyy + 2*exy*exy);

  double mu_r = gamma_m * paraInput.xi;
  double mu_g = mu_m - mu_r * g_int;
  double gamma_g = gamma_m * g_int;

  double EPS_SMALL = 1e-30;

  double Q11 = 1/rho_m * ( lambda_m + 2*mu_g - gamma_g * (
                              exx/std::sqrt(EII+EPS_SMALL) + ( (2*exx + eyy)*EII
                                                    - exx*exx*EI )/std::pow(EII+EPS_SMALL,1.5)  ) 
                          );
  double Q13 = 1/rho_m * (-gamma_g) * ( 2*exy/std::sqrt(EII+EPS_SMALL) 
                                        - 2*exy*exx*EI/std::pow(EII+EPS_SMALL,1.5) ) ;

  double Q21 = 1/rho_m * (-gamma_g) * ( exy/std::sqrt(EII+EPS_SMALL) 
                                        - exy*exx*EI/std::pow(EII+EPS_SMALL,1.5) ) ;

  double Q23 = 1/rho_m * ( 2*mu_g - gamma_g * EI * (exx*exx + eyy*eyy)/std::pow(EII+EPS_SMALL,1.5) );

  double cp = 0.5*std::sqrt(2*Q11 + Q23 + std::sqrt( (2*Q11 - Q23)*(2*Q11 - Q23) + 8*Q13*Q21 ) );

  Q[6] = EI/std::sqrt(EII+1e-30) + paraInput.xi;
  Q[7] = -( rho_m*cp*cp )
          /(paraInput.lambda+2*paraInput.mu) + 1;
  // 1 - (1-g_int) * (1 - paraInput.beta * (exx-paraInput.exx0) - paraInput.delta * (exx-paraInput.exx0)*(exx-paraInput.exx0) );
}

void IVM::IVM_ADERDG::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int direction,const double* const fluxIn,const double* const stateIn,const double* const gradStateIn,double* const fluxOut,double* const stateOut) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.

  // @todo Please implement/augment if required
  VariableShortcuts s;

  double lambda_m = paraInput.lambda; //12.5e9; stateIn[6]; 4.72e9
  // std::cout << "lambda0: " << lambda_m << ", Q[6]: " << stateOut[6] << "\n";
  // std::cout << "Lambda: " << stateIn[6] << "\n";
  double mu_m = paraInput.mu; //18.75e9;
  double alpha_m = lambda_m/(lambda_m+2*mu_m);

  const int nDim = DIMENSIONS;

  std::copy_n(stateIn, NumberOfVariables, stateOut);
  // stateOut[s.v+0] =  -stateOut[s.v+0];
  // stateOut[s.v+1] =  -stateOut[s.v+1];
  // stateOut[s.e+direction] =  -stateOut[s.e+direction] - 2.0*alpha_m*(stateOut[s.e+(1-direction)] + paraInput.eyy0) 
  //                             - 2*paraInput.exx0;
  stateOut[s.e+direction] = -stateOut[s.e+direction];
  stateOut[s.e+2] =  -stateOut[s.e+2] + 2*paraInput.exy0;
  //if ( t<tc1 && std::sqrt(x[0]*x[0]) < 0.01 && std::sqrt((x[1]-0.11)*(x[1]-0.11)) < 0.02 ){
    for (int i=0; i<=Order+1; i++) {
      const double ti = t + dt * kernels::legendre::nodes[Order][i];
      double ei = setYourExactData(x,ti) + 0.5*paraInput.exx0;
      // double tout = t; 
      // if (std::abs(tout - tout_old) > 1/70e3/4){
      //   std::cout << "============================" << "\n";
      //   std::cout << tout << ", " << ei << "\n";
      //   tout_old = tout;
      // }
      

      stateOut[s.e+direction] += 2 * ei * kernels::legendre::weights[Order][i];
    }
  //}
  
  double _F[nDim][NumberOfVariables]={0.0};
  double* F[nDim] = {_F[0], _F[1]};

  flux(stateOut,F);
  
  std::copy_n(F[direction], NumberOfVariables, fluxOut);


  // stateOut[0] = 0.0;
  // stateOut[1] = 0.0;
  // stateOut[2] = 0.0;
  // stateOut[3] = 0.0;
  // stateOut[4] = 0.0;
  // stateOut[5] = 0.0;

  // fluxOut[0] = 0.0;
  // fluxOut[1] = 0.0;
  // fluxOut[2] = 0.0;
  // fluxOut[3] = 0.0;
  // fluxOut[4] = 0.0;
  // fluxOut[5] = 0.0;
}

exahype::solvers::Solver::RefinementControl IVM::IVM_ADERDG::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,double t,const int level) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  // Tip: See header file "peano/utils/Loop.h" for dimension-agnostic for loops.
  
  //  Example: Loop over all pointwise state variables (plus parameters)
  //
  //  constexpr int sizeOfQ = NumberOfVariables+NumberOfParameters;
  //  dfor(i,Order+1) {
  //    const int iLinearised = dLinearised(i,Order+1);
  //    const double* const Q = luh + iLinearised * sizeOfQ; // pointwise state variables (plus parameters)
  //    // use Q[0], Q[1], ... Q[sizeOfQ-1]
  //  }
  
  // @todo Please implement/augment if required
  return exahype::solvers::Solver::RefinementControl::Keep;
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void IVM::IVM_ADERDG::eigenvalues(const double* const Q,const int direction,double* const lambda) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  
  // @todo Please implement/augment if required
  double lambda_m = paraInput.lambda; //12.5e9;
  double mu_m = paraInput.mu; //18.75e9;
  double rho_m = paraInput.rho;
  double gamma_m = paraInput.gamma;
//  double l_m = -0.0e5;
//  double m_m = -0.0e5;
  VariableShortcuts s;

  double vx = Q[s.v]; double vy = Q[s.v+1];
  double exx = Q[s.e]; double eyy = Q[s.e+1]; double exy = Q[s.e+2];
  double g_int = Q[s.gint];

  double EI = exx + eyy;
  double EII = (exx*exx + eyy*eyy + 2*exy*exy);

  double mu_r = gamma_m * paraInput.xi;
  double mu_g = mu_m - mu_r * g_int;
  double gamma_g = gamma_m * g_int;

  double EPS_SMALL = 1e-18;

  double Q11 = 1/rho_m * ( lambda_m + 2*mu_g - gamma_g * (
                              exx/std::sqrt(EII+EPS_SMALL) + ( (2*exx + eyy)*EII
                                                    - exx*exx*EI )/std::pow(EII+EPS_SMALL,1.5)  ) 
                          );
  double Q13 = 1/rho_m * (-gamma_g) * ( 2*exy/std::sqrt(EII+EPS_SMALL) 
                                        - 2*exy*exx*EI/std::pow(EII+EPS_SMALL,1.5) ) ;

  double Q21 = 1/rho_m * (-gamma_g) * ( exy/std::sqrt(EII+EPS_SMALL) 
                                        - exy*exx*EI/std::pow(EII+EPS_SMALL,1.5) ) ;

  double Q23 = 1/rho_m * ( 2*mu_g - gamma_g * EI * (exx*exx + eyy*eyy)/std::pow(EII+EPS_SMALL,1.5) );

/*
  double Q11 = (1-Q[s.gint])/rho_m * ( lambda_m + 2*mu_m );
  double Q13 = (1-Q[s.gint])/rho_m * 0;
  double Q21 = (1-Q[s.gint])/rho_m * 0;
  double Q23 = (1-Q[s.gint])/rho_m * 2 * (mu_m);
*/
  double cp = 0.5*std::sqrt(2*Q11 + Q23 + std::sqrt( (2*Q11 - Q23)*(2*Q11 - Q23) + 8*Q13*Q21 ) );
  double cs = 0.5*std::sqrt(2*Q11 + Q23 - std::sqrt( (2*Q11 - Q23)*(2*Q11 - Q23) + 8*Q13*Q21 ) );

  lambda[0] = cp;
  lambda[1] = -cp;
  lambda[2] = cs;
  lambda[3] = -cs;
  lambda[4] = 0.0;
  lambda[5] = 0.0;

  // lambda[0] = 1.0;
  // lambda[1] = 1.0;
  // lambda[2] = 1.0;
  // lambda[3] = 1.0;
  // lambda[4] = 1.0;
  // lambda[5] = 1.0;
}





void IVM::IVM_ADERDG::flux(const double* const Q,double** const F) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  
  // @todo Please implement/augment if required
  double lambda_m = paraInput.lambda; //12.5e9;
  double mu_m = paraInput.mu; //18.75e9;
  double rho_m = paraInput.rho;
  double gamma_m = paraInput.gamma;
//  double l_m = -2.0e5;
//  double m_m = -2.0e5;
  VariableShortcuts s;

  double vx = Q[s.v]; double vy = Q[s.v+1];
  double exx = Q[s.e]; double eyy = Q[s.e+1]; double exy = Q[s.e+2];
  double g_int = Q[s.gint];

  double EI = exx + eyy;
  double EII = (exx*exx + eyy*eyy + 2*exy*exy);

  double mu_r = gamma_m * paraInput.xi;
  double mu_g = mu_m - mu_r * g_int;
  double gamma_g = gamma_m * g_int;

  double EPS_SMALL = 1e-18;

  //std::cout << m_m << "\n";

  double sxx = lambda_m*EI + 2*mu_g*exx - gamma_g*std::sqrt(EII) - gamma_g*EI/std::sqrt(EII+EPS_SMALL)*exx;
  double syy = lambda_m*EI + 2*mu_g*eyy - gamma_g*std::sqrt(EII) - gamma_g*EI/std::sqrt(EII+EPS_SMALL)*eyy;
  double sxy = 2*mu_g*exy - gamma_g*EI/std::sqrt(EII+EPS_SMALL)*exy;


  F[0][0] = vx;
  F[0][1] = 0.0;
  F[0][2] = 0.5*vy;
  F[0][3] = sxx/rho_m;
  F[0][4] = sxy/rho_m;
  F[0][5] = 0.0;
  
  F[1][0] = 0.0;
  F[1][1] = vy;
  F[1][2] = 0.5*vx;
  F[1][3] = sxy/rho_m;
  F[1][4] = syy/rho_m;
  F[1][5] = 0.0;
  
}


//You can either implement this method or modify fusedSource
void IVM::IVM_ADERDG::algebraicSource(const tarch::la::Vector<DIMENSIONS, double>& x, double t, const double *const Q, double *S) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  // @todo Please implement/augment if required
  double PI = 3.141592654;
  double fc = 100e3;
  double tc1 = 0.2e-4;
  double A_amp = 1e4*(t/tc1)*9.23;

  double lambda_m = paraInput.lambda; //12.5e9;
  double mu_m = paraInput.mu; //18.75e9;
  double rho_m = paraInput.rho;
  double gamma_m = paraInput.gamma;
//  double l_m = -2.0e5;
//  double m_m = -2.0e5;
  double tau_1  = paraInput.tau1;
  VariableShortcuts s;

  double vx = Q[s.v]; double vy = Q[s.v+1];
  double exx = Q[s.e]; double eyy = Q[s.e+1]; double exy = Q[s.e+2];
  double g_int = Q[s.gint];
  double EI = exx + eyy;
  double EII = (exx*exx + eyy*eyy + 2*exy*exy);
  double EPS_SMALL = 1e-30;

  double xi_e = EI / std::sqrt(EII+EPS_SMALL);

  // double energyW = lambda_m/2*EI*EI + 2*mu_m*(1/2*EI*EI-EII) + (l_m+2*m_m)/3*EI*EI*EI - 2*m_m*EI*EII;
  // std::cout << xi_e << std::endl;

  S[0] = 0.0;
  S[1] = 0.0;
  S[2] = 0.0;
  S[3] = (t<tc1 && std::sqrt(x[0]*x[0]) < 0.00101 && std::sqrt((x[1]-0.11)*(x[1]-0.11)) < 0.02) ? 0*std::sin(2*PI*fc*t) : 0;;
  S[4] = 0.0;
  if (xi_e+paraInput.xi>=0){
    S[5] = paraInput.Cd * gamma_m * ( EI*std::sqrt(EII) + paraInput.xi*EII );
    // std::cout << g_int << std::endl;
  }
  else if (xi_e+paraInput.xi<0 && g_int > -1e-30 ){
    S[5] = paraInput.Cr * g_int * gamma_m * ( EI*std::sqrt(EII) + paraInput.xi*EII );
    // std::cout << g_int << std::endl;
  }
  else{
    S[5] = 0;
    // std::cout << g_int << std::endl;
  }
  // S[5] = (xi_e+paraInput.xi>=0) ? 1/(tau_1)*( EI*std::sqrt(EII) + paraInput.xi*EII ) 
  //                   : 1e5 * g_int * 1/(tau_1)*( EI*std::sqrt(EII) + paraInput.xi*EII ) ;
                    // 1e3*g_int*std::exp(g_int/1e-4)
}



