// This file was generated by the ExaHyPE toolkit.
// It will not be overwritten.
//
//
// ========================
//   www.exahype.eu
// ========================
#include "Writers/PointsSol.h"
#include "kernels/GaussLegendreBasis.h"
#include <algorithm>

namespace output_Points{
  int o_count = 0;
  int N_points = 40; // Number of points to sample along the path
  // Single delay along the path
  struct Q_out {
    std::vector<double> Q = std::vector<double>(40,0.0);
    int count = 0;
  };
  // Different delays
  std::vector<Q_out> Qs = std::vector<Q_out>(40);
  double outputq;
  bool create_file = true;
}

IVM::PointsSol::PointsSol() : exahype::plotters::ADERDG2UserDefined::ADERDG2UserDefined(){
  // @TODO Please insert your code here.
}

void IVM::PointsSol::plotPatch(
    const tarch::la::Vector<DIMENSIONS, double>& offsetOfPatch,
    const tarch::la::Vector<DIMENSIONS, double>& sizeOfPatch, double* const u,
    double timeStamp) {
  // @TODO Please insert your code here.
  tarch::la::Vector<DIMENSIONS,double> x;
  double dist_incre = 2.865e-3;
  x(1) = 0.065;
  int unkonwn = 7;
  double* interpoland = new double[1];
  int i_out = output_Points::o_count;

  for (int i_samp = std::max(i_out-39,0); 
        i_samp < std::min(i_out+1,40); i_samp++ ){
    x(0) = dist_incre*i_samp; x(1) = 0.065;

    if (tarch::la::allSmallerEquals(offsetOfPatch,x) && 
    tarch::la::allGreater(offsetOfPatch+sizeOfPatch,x)){
      interpoland[0] = kernels::legendre::interpolate(
          offsetOfPatch.data(),
          sizeOfPatch.data(),
          x.data(),
          _variables,
          unkonwn,
          _order,
          u
        );
      // output_Points::outputq = interpoland[0];
      output_Points::Qs[i_out-i_samp].Q[i_samp] = interpoland[0];

      // int unkonwn = 5;

      // interpoland[0] = kernels::legendre::interpolate(
      //     offsetOfPatch.data(),
      //     sizeOfPatch.data(),
      //     x.data(),
      //     _variables,
      //     unkonwn,
      //     _order,
      //     u
      //   );
      // output_Points::Qs2[i_out-i_samp].Q[i_samp] = -interpoland[0];

      // unkonwn = 6;

      // interpoland[0] = kernels::legendre::interpolate(
      //     offsetOfPatch.data(),
      //     sizeOfPatch.data(),
      //     x.data(),
      //     _variables,
      //     unkonwn,
      //     _order,
      //     u
      //   );
      // output_Points::Qs3[i_out-i_samp].Q[i_samp] = interpoland[0];
    }
    

  }
}
void IVM::PointsSol::startPlotting( double time) {
  // @TODO Please insert your code here.
}


void IVM::PointsSol::finishPlotting() {
  // @TODO Please insert your code here.
  std::string home_dir = std::getenv("SHARED_DIR");
  std::string finame;
  finame = home_dir + "/out.txt";
  std::ofstream outputsfile;

  // std::string finame2;
  // finame2 = home_dir + "/Exahype/outPointsF_Mg.txt";
  // std::ofstream outputsfile2;

  // std::string finame3;
  // finame3 = home_dir + "/Exahype/outPointsF_Mxi.txt";
  // std::ofstream outputsfile3;

  std::cout << finame << std::endl;

  if (output_Points::o_count > 78.5)
  {
    outputsfile.open(finame, std::ios_base::trunc);
    outputsfile << std::fixed << std::scientific;

    // // Full output
    // for (int i_d = 0; i_d < 40; i_d++){
    //   for (int i_s = 0; i_s < 40; i_s++){
    //     outputsfile << output_Points::Qs[i_d].Q[i_s] << ",";
    //   }
    //   long pos = outputsfile.tellp(); // gets the current position of the buffer ( in this case 19)
    //   outputsfile.seekp(pos - 1);
    //   outputsfile << std::endl;
    // }

    // Required output
    for (int i_d = 0; i_d < 40; i_d++){
      double out_d = 0;
      for (int i_s = 0; i_s < 40; i_s++){
        out_d += output_Points::Qs[i_d].Q[i_s];
      }
      outputsfile << out_d/40 << std::endl;
    }

    outputsfile.close();

    // outputsfile2.open(finame2, std::ios_base::trunc);
    // outputsfile2 << std::fixed << std::scientific;

    // for (int i_d = 0; i_d < 40; i_d++){
    //   double out_d = 0;
    //   for (int i_s = 0; i_s < 40; i_s++){
    //     out_d += output_Points::Qs2[i_d].Q[i_s];
    //   }
    //   outputsfile2 << out_d/40 << std::endl;
    // }
    // outputsfile2.close();

    // outputsfile3.open(finame3, std::ios_base::trunc);
    // outputsfile3 << std::fixed << std::scientific;

    // for (int i_d = 0; i_d < 40; i_d++){
    //   double out_d = 0;
    //   for (int i_s = 0; i_s < 40; i_s++){
    //     out_d += output_Points::Qs3[i_d].Q[i_s];
    //   }
    //   outputsfile3 << out_d/40 << std::endl;
    // }
    // outputsfile3.close();
  }

  // if (output_Points::create_file){
  //   std::cout << finame  << std::endl;
  //   outputsfile.open(finame, std::ios_base::trunc);
  //   outputsfile.close();
  //   output_Points::create_file = false;
  // }
  // outputsfile.open(finame, std::ios_base::app);
  // outputsfile << std::fixed << std::scientific;
  // outputsfile << output_Points::outputq << "," << output_Points::o_count << std::endl;
  // // std::cout << "===============" << _variables << std::endl;
  // outputsfile.close();
  output_Points::o_count += 1;  
}