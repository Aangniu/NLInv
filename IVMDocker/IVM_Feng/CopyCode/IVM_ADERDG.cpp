// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "IVM_ADERDG.h"

#include "IVM_ADERDG_Variables.h"

#include "kernels/KernelUtils.h"

#include "kernels/GaussLegendreBasis.h"
#include "kernels/aderdg/generic/Kernels.h"

#include "peano/utils/Loop.h"

tarch::logging::Log IVM::IVM_ADERDG::_log( "IVM::IVM_ADERDG" );

bool create_file = true;
bool write_file = true;
bool read_file = true;

// struct ParaReadIn { // This structure is named "myDataType"
//   double lambda;
//   double mu;
//   double beta;
//   double delta;
//   double rho;
//   double gamma;
//   double tau1;
// };

ParaReadIn paraInput;

std::vector<double> var_in(5);

double setYourExactData(const double* const x, const double t){
  double PI = 3.141592654;
  double fc = 74e3;
  double fc_pro = 600e3;
  // double tc1 = 3/fc;
  // double A_amp = 1e-6*(t/tc1)*(3-9*t/4/tc1);
  // double A_amp = 5e-5*( 1-1.5*std::abs((t/tc1)-0.6667) );
  double tc1 = 4/fc;
  double tc2 = 0.5/fc_pro;
  
  double A_amp = 2.5e-6*( 1.0-2.0*std::abs((t/tc1)-0.5) );
  // double A_amp = 5e-5*4*( (1.0-t/tc1)*t/tc1 );

  double s_sou;

  if (t<tc1 && std::sqrt(x[0]*x[0]) < 0.01 && std::sqrt((x[1]-0.11)*(x[1]-0.11)) < 0.02){
    s_sou = A_amp*std::sin(2*PI*fc*t);
  }
  else if (t<tc2 && std::sqrt(x[0]*x[0]) < 0.00101 && std::sqrt((x[1]-0.065)*(x[1]-0.065)) < 0.005){
    s_sou = 0e-6*std::sin(2*PI*fc_pro*t);
  }
  else{
    s_sou = 0;
  }

  return s_sou;
}

void IVM::IVM_ADERDG::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  
  // @todo Please implement/augment if required

    
}

void IVM::IVM_ADERDG::adjustPointSolution(const double* const x,const double t,const double dt,double* const Q) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  
  // @todo Please implement/augment if required
  typedef std::numeric_limits<double> dl;
  if (tarch::la::equals(t,0.0)) {
    Q[0] = 0.0;
    Q[1] = 0.0;
    Q[2] = 0.0;
    Q[3] = 0.0;
    Q[4] = 0.0;
    Q[5] = 0.0;

    // std::cout << "Entered Output======" << std::endl;
    std::string home_dir = std::getenv("SHARED_DIR");
    // std::string finame;
    // finame = home_dir + "/Exahype/out.txt";
    // std::ofstream outputsfile;
    // if (create_file) {
    //   outputsfile.open(finame, std::ios_base::trunc);
    //   outputsfile.close();
    //   create_file = false;
    // }
    // if (write_file){
    //   std::cout << finame << std::endl;
    //   outputsfile.open(finame, std::ios_base::app);
    //   outputsfile << std::fixed << std::setprecision(3);
    //   for(int i = 0; i<7; i++) outputsfile << Q[i] << "\n";
    //   outputsfile.close();
    //   write_file = false;
    // }
    std::string finame_in;
    finame_in = home_dir + "/in.txt";
    std::ifstream inputsfile;
    
    if (read_file){
      read_file = false;
      std::cout << "Reading from " << finame_in << "\n";
      inputsfile.open(finame_in, std::ios_base::in);
      inputsfile >> std::fixed >> std::scientific;
      for(int i=0; i<4; i++){
        inputsfile >> var_in[i];
        std::cout << "Read in: " << var_in[i] << "\n";
      }
      paraInput.lambda = 4.72e9;
      paraInput.mu = 7.08e9;
      paraInput.beta = var_in[0]*180;
      paraInput.delta = var_in[1]*3e8;
      paraInput.rho = 1*2.3e3;
      paraInput.gamma = std::pow(10,var_in[2]); //1*10;
      paraInput.tau1 = std::pow(10,var_in[3])*1e-6;
      // paraInput.rho = var_in[2]*2.3e3;
      // paraInput.gamma = var_in[3]*10;
      // paraInput.tau1 = var_in[4]*2e-6;
      // mu0 = var_in;
      // rho0 = var_in;

      std::cout << "Read-in parameters\n";
      std::cout << "lambda0 = " << paraInput.lambda  << std::endl;
      std::cout << "mu0     = " << paraInput.mu << std::endl;
      std::cout << "beta    = " << paraInput.beta  << std::endl;
      std::cout << "delta   = " << paraInput.delta << std::endl;
      std::cout << "rho0    = " << paraInput.rho << std::endl;
      std::cout << "gamma0  = " << paraInput.gamma << std::endl;
      std::cout << "tau10   = " << paraInput.tau1 << std::endl;
       
    }
    // Q[6] = var_in;
    // if (Q[6]>0.1) {
    //   std::cout << "Lambda111: " << var_in << ", Q[6]: " << Q[6] << "\n";
    // }
    
    
  }
  Q[6] = (1-(1-1*Q[5])*(1-paraInput.beta*Q[0] - paraInput.delta*Q[0]*Q[0]));
}

void IVM::IVM_ADERDG::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int direction,const double* const fluxIn,const double* const stateIn,const double* const gradStateIn,double* const fluxOut,double* const stateOut) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.

  // @todo Please implement/augment if required

  // Defining your constants
  

  VariableShortcuts s;

  double lambda_m = paraInput.lambda; //12.5e9; stateIn[6]; 4.72e9
  // std::cout << "lambda0: " << lambda_m << ", Q[6]: " << stateOut[6] << "\n";
  // std::cout << "Lambda: " << stateIn[6] << "\n";
  double mu_m = paraInput.mu; //18.75e9;
  double alpha_m = lambda_m/(lambda_m+2*mu_m);

  const int nDim = DIMENSIONS;

  std::copy_n(stateIn, NumberOfVariables, stateOut);
  // stateOut[s.v+0] =  -stateOut[s.v+0];
  // stateOut[s.v+1] =  -stateOut[s.v+1];
  stateOut[s.e+direction] =  -stateOut[s.e+direction] - 2.0*alpha_m*stateOut[s.e+(1-direction)];
  stateOut[s.e+2] =  -stateOut[s.e+2];
  //if ( std::sqrt(x[0]*x[0]) < 0.00101 && std::sqrt((x[1]-0.11)*(x[1]-0.11)) < 0.02 ){
    for (int i=0; i<=Order+1; i++) {
      const double ti = t + dt * kernels::legendre::nodes[Order][i];
      double ei = setYourExactData(x,ti);
      // double tout = t; 
      // if (std::abs(tout - tout_old) > 1/70e3/4){
      //   std::cout << "============================" << "\n";
      //   std::cout << tout << ", " << ei << "\n";
      //   tout_old = tout;
      // }
      

      stateOut[s.e+direction] += 2 * ei * kernels::legendre::weights[Order][i];
    }
  //}
  
  double _F[nDim][NumberOfVariables]={0.0};
  double* F[nDim] = {_F[0], _F[1]};

  flux(stateOut,F);
  
  std::copy_n(F[direction], NumberOfVariables, fluxOut);

  // Free surface
  // stateOut[0] = stateIn[0];
  // stateOut[1] = stateIn[1];
  // stateOut[2] = stateIn[2];
  // stateOut[3] = stateIn[3];
  // stateOut[4] = stateIn[4];
  // stateOut[5] = stateIn[5];

  // fluxOut[0] = -fluxIn[0];
  // fluxOut[1] = -fluxIn[1];
  // fluxOut[2] = -fluxIn[2];
  // fluxOut[3] = fluxIn[3];
  // fluxOut[4] = fluxIn[4];
  // fluxOut[5] = fluxIn[5];


  // Outflow BC
  // stateOut[0] = stateIn[0];
  // stateOut[1] = stateIn[1];
  // stateOut[2] = stateIn[2];
  // stateOut[3] = stateIn[3];
  // stateOut[4] = stateIn[4];
  // stateOut[5] = stateIn[5];

  // fluxOut[0] = fluxIn[0];
  // fluxOut[1] = fluxIn[1];
  // fluxOut[2] = fluxIn[2];
  // fluxOut[3] = fluxIn[3];
  // fluxOut[4] = fluxIn[4];
  // fluxOut[5] = fluxIn[5];

}

exahype::solvers::Solver::RefinementControl IVM::IVM_ADERDG::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,double t,const int level) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  // Tip: See header file "peano/utils/Loop.h" for dimension-agnostic for loops.
  
  //  Example: Loop over all pointwise state variables (plus parameters)
  //
  //  constexpr int sizeOfQ = NumberOfVariables+NumberOfParameters;
  //  dfor(i,Order+1) {
  //    const int iLinearised = dLinearised(i,Order+1);
  //    const double* const Q = luh + iLinearised * sizeOfQ; // pointwise state variables (plus parameters)
  //    // use Q[0], Q[1], ... Q[sizeOfQ-1]
  //  }
  
  // @todo Please implement/augment if required
  return exahype::solvers::Solver::RefinementControl::Keep;
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void IVM::IVM_ADERDG::eigenvalues(const double* const Q,const int direction,double* const lambda) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  
  // @todo Please implement/augment if required
  double lambda_m = paraInput.lambda; //12.5e9;
  double mu_m = paraInput.mu; //18.75e9;
  double rho_m = paraInput.rho;
//  double l_m = -0.0e5;
//  double m_m = -0.0e5;
  VariableShortcuts s;

  double vx = Q[s.v]; double vy = Q[s.v+1];
  double exx = Q[s.e]; double eyy = Q[s.e+1]; double exy = Q[s.e+2];
  double g_int = Q[s.gint];

  double EI = exx + eyy;
  double EII = (exx*eyy - exy*exy);


  double Q11 = (1-g_int)/rho_m * ( 2*(l_m + 2*m_m)*exx + 2*l_m*eyy + lambda_m + 2*mu_m );
  double Q13 = (1-g_int)/rho_m * 4 * m_m * exy;
  double Q21 = (1-g_int)/rho_m * 2 * m_m * exy;
  double Q23 = (1-g_int)/rho_m * 2 * (m_m*EI + mu_m);

/*
  double Q11 = (1-Q[s.gint])/rho_m * ( lambda_m + 2*mu_m );
  double Q13 = (1-Q[s.gint])/rho_m * 0;
  double Q21 = (1-Q[s.gint])/rho_m * 0;
  double Q23 = (1-Q[s.gint])/rho_m * 2 * (mu_m);
*/
  double cp = 0.5*std::sqrt(2*Q11 + Q23 + std::sqrt( (2*Q11 - Q23)*(2*Q11 - Q23) + 8*Q13*Q21 ) );
  double cs = 0.5*std::sqrt(2*Q11 + Q23 - std::sqrt( (2*Q11 - Q23)*(2*Q11 - Q23) + 8*Q13*Q21 ) );

  lambda[0] = cp;
  lambda[1] = -cp;
  lambda[2] = cs;
  lambda[3] = -cs;
  lambda[4] = 0.0;
  lambda[5] = 0.0;
}




void IVM::IVM_ADERDG::flux(const double* const Q,double** const F) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  
  // @todo Please implement/augment if required
  double lambda_m = paraInput.lambda; //12.5e9;
  double mu_m = paraInput.mu; //18.75e9;
  double rho_m = paraInput.rho;
//  double l_m = -2.0e5;
//  double m_m = -2.0e5;
  VariableShortcuts s;

  double vx = Q[s.v]; double vy = Q[s.v+1];
  double exx = Q[s.e]; double eyy = Q[s.e+1]; double exy = Q[s.e+2];

  double EI = exx + eyy;
  double EII = (exx*eyy - exy*exy);

  //std::cout << m_m << "\n";

  double sxx = lambda_m*EI + l_m*EI*EI - 2*m_m*EII + 2*(mu_m + m_m*EI)*exx;
  double syy = lambda_m*EI + l_m*EI*EI - 2*m_m*EII + 2*(mu_m + m_m*EI)*eyy;
  double sxy = 2*(mu_m + m_m*EI)*exy;



  F[0][0] = vx;
  F[0][1] = 0.0;
  F[0][2] = 0.5*vy;
  F[0][3] = (1-Q[s.gint])*sxx/rho_m;
  F[0][4] = (1-Q[s.gint])*sxy/rho_m;
  F[0][5] = 0.0;
  
  F[1][0] = 0.0;
  F[1][1] = vy;
  F[1][2] = 0.5*vx;
  F[1][3] = (1-Q[s.gint])*sxy/rho_m;
  F[1][4] = (1-Q[s.gint])*syy/rho_m;
  F[1][5] = 0.0;
}


//You can either implement this method or modify fusedSource
void IVM::IVM_ADERDG::algebraicSource(const tarch::la::Vector<DIMENSIONS, double>& x, double t, const double *const Q, double *S) {
  // Tip: You find documentation for this method in header file "IVM::IVM_ADERDG.h".
  // Tip: See header file "IVM::AbstractIVM_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  // @todo Please implement/augment if required
  
  double PI = 3.141592654;
  double fc = 100e3;
  double tc1 = 0.2e-4;
  double A_amp = 1e4*(t/tc1)*9.23;

  double lambda_m = paraInput.lambda; //12.5e9;
  double mu_m = paraInput.mu; //18.75e9;
  double rho_m = paraInput.rho;
  double gamma_m = paraInput.gamma;
//  double l_m = -2.0e5;
//  double m_m = -2.0e5;
  double tau_1  = paraInput.tau1;
  VariableShortcuts s;

  double vx = Q[s.v]; double vy = Q[s.v+1];
  double exx = Q[s.e]; double eyy = Q[s.e+1]; double exy = Q[s.e+2];
  double EI = exx + eyy;
  double EII = (exx*eyy - exy*exy);
  double energyW = lambda_m/2*EI*EI + 2*mu_m*(1/2*EI*EI-EII) + (l_m+2*m_m)/3*EI*EI*EI - 2*m_m*EI*EII;

  S[0] = 0.0;
  S[1] = 0.0;
  S[2] = 0.0;
  S[3] = (t<tc1 && std::sqrt(x[0]*x[0]) < 0.00101 && std::sqrt((x[1]-0.11)*(x[1]-0.11)) < 0.02) ? 0*std::sin(2*PI*fc*t) : 0;;
  S[4] = 0.0;
  S[5] = 1/(gamma_m*tau_1)*( energyW - gamma_m*Q[s.gint]/(1-Q[s.gint]*Q[s.gint]) );
}



